// -*- C++ -*-
//
// Package:    GenLevelBJetProducer
// Class:      GenLevelBJetProducer
//
/**\class GenLevelBJetProducer GenLevelBJetProducer.cc blutz/GenLevelBJetProducer/src/GenLevelBJetProducer.cc
* @brief matches GenJets versus b-hadrons
*
* Identifies the b-Jets inside the generator jets by matching it with the b-hadrons.
*
* A detailed description of the algorithm can be found at getGenJetWith()
*
* The description of the run-time parameters can be found at fillDescriptions()
*
* The description of the products can be found at GenLevelBJetProducer()
*/

//
// Original Author:  Benjamin Lutz,DESY
//         Created:  Thu Feb  2 13:30:58 CET 2012
// $Id: GenLevelBJetProducer.cc,v 1.14 2013/04/09 08:35:42 nbartosi Exp $
//
//


// system include files
#include <memory>


// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDProducer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

// added by me
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/Framework/interface/EventSetup.h"

#include "DataFormats/JetReco/interface/GenJet.h"
#include "DataFormats/Math/interface/deltaR.h"

#include "AnalysisDataFormats/TopObjects/interface/TtGenEvent.h"

#include "SimGeneral/HepPDTRecord/interface/ParticleDataTable.h"


//
// class declaration
//

class GenLevelBJetProducer : public edm::EDProducer
{
public:
    explicit GenLevelBJetProducer ( const edm::ParameterSet& );
    ~GenLevelBJetProducer();

    static void fillDescriptions ( edm::ConfigurationDescriptions& descriptions );

private:
    virtual void beginJob() ;
    virtual void produce ( edm::Event&, const edm::EventSetup& );
    virtual void endJob() ;

    virtual void beginRun ( edm::Run&, edm::EventSetup const& );
    virtual void endRun ( edm::Run&, edm::EventSetup const& );
    virtual void beginLuminosityBlock ( edm::LuminosityBlock&, edm::EventSetup const& );
    virtual void endLuminosityBlock ( edm::LuminosityBlock&, edm::EventSetup const& );

    std::vector<int> getGenJetWith ( const reco::Candidate* bQuark, const reco::GenJetCollection& genJets, std::vector<reco::GenParticle> &bHadronObjects, std::vector<bool> &isFromBquark, std::vector<int> &bHadronsInJet );
    int getGenJetNear ( const reco::Candidate* particle, std::vector<const reco::GenJet*> &genJets );
    typedef const reco::Candidate* pCRC;
    bool searchInMothers ( const reco::Candidate* bQuark, const reco::Candidate* thisParticle, std::vector<const reco::Candidate*> particleChain, pCRC *bHadron );
    bool hasHadronDaughter ( const int flavour, const reco::Candidate* thisParticle );

    bool checkForLoop ( std::vector<const reco::Candidate*> &particleChain, const reco::Candidate* particle );
    std::string getParticleName ( int id ) const;

    inline std::string printJetInfo ( const size_t iJet, const reco::GenJet* ) const;
    inline std::string printParticleChain ( const std::vector<const reco::Candidate*> &particleChain, const reco::Candidate *bHadron ) const;

// ----------member data ---------------------------
    edm::InputTag ttGenEvent_;
    edm::InputTag genJets_;
    double deltaR_;
    bool noBBbarResonances_;
    bool requireTopBquark_;
    bool resolveName_;

    std::string flavourStr_;  // Name of the flavour specified in config file

    edm::ESHandle<ParticleDataTable> pdt_;


};

//
// constants, enums and typedefs
//


//
// static data member definitions
//

//
// constructors and destructor
//
/**
* @brief constructor initialising producer products and config parameters
*
* Output generated by this producer:
* <TABLE>
* <TR><TH> name                </TH><TH> type                           </TH><TH> description </TH> </TR>
* <TR><TD> BHadJetIndex        </TD><TD> std::vector<int>               </TD><TD> position of the jet identified as b-hadron jet in the input GenJetCollection </TD></TR>
* <TR><TD> BHadrons            </TD><TD> std::vector<reco::GenParticle> </TD><TD> vector of the identified b-hadrons (definition of b-hadron and anti-b-hadron below) </TD></TR>
* <TR><TD> BHadronFromTopB     </TD><TD> std::vector<bool>              </TD><TD> true if the corresponding b-hadron originates from the ttGenEvent b-quark </TD></TR>
* <TR><TD> BHadronVsJet        </TD><TD> std::vector<int>               </TD><TD> matrix of which b-hadron appears in which GenJet, access by [iJet * BHadrons.size() + iBhadron] </TD></TR>
*
* <TR><TD> AntiBHadJetIndex    </TD><TD> std::vector<int>               </TD><TD> position of the jet identified as anti-b-hadron jet in the input GenJetCollection </TD></TR>
* <TR><TD> AntiBHadrons        </TD><TD> std::vector<reco::GenParticle> </TD><TD> vector of the identified anti-b-hadrons (definition of b-hadron and anti-b-hadron below) </TD></TR>
* <TR><TD> AntiBHadronFromTopB </TD><TD> std::vector<bool>              </TD><TD> true if the corresponding anti-b-hadron originates from the ttGenEvent anti-b-quark </TD></TR>
* <TR><TD> AntiBHadronVsJet    </TD><TD> std::vector<int>               </TD><TD> matrix of which anti-b-hadron appears in which GenJet, access by [iJet * AntiBHadrons.size() + iBhadron] </TD></TR>
*
* </TABLE>
*
* @warning Definition of b-hadron and anti-b-hadron: The term b-hadron and anti-b-hadron is in reference to the quark content and <b>not</b> to distinguish particles from anti-particles.
* Here a b-hadron contains a b-quark and an anti-b-hadron contains an anti-b-quark.
* For mesons this means an inversion with respect to the PDG definition, as mesons actually contain anti-b-quarks and anti-mesons contain b-quarks.
*
*/
GenLevelBJetProducer::GenLevelBJetProducer ( const edm::ParameterSet& cfg )
{

    ttGenEvent_        = cfg.getParameter<edm::InputTag> ( "ttGenEvent" );
    genJets_           = cfg.getParameter<edm::InputTag> ( "genJets" );
    deltaR_            = cfg.getParameter<double> ( "deltaR" );
    noBBbarResonances_ = cfg.getParameter<bool> ( "noBBbarResonances" );
    requireTopBquark_  = cfg.getParameter<bool> ( "requireTopBquark" );
    resolveName_       = cfg.getParameter<bool> ( "resolveParticleName" );


    produces< std::vector<int> > ( "BHadJetIndex" );
    produces< std::vector<reco::GenParticle> > ( "BHadrons" );
    produces< std::vector<bool> > ( "BHadronFromTopB" );
    produces< std::vector<int> > ( "BHadronVsJet" );

    produces< std::vector<int> > ( "AntiBHadJetIndex" );
    produces< std::vector<reco::GenParticle> > ( "AntiBHadrons" );
    produces< std::vector<bool> > ( "AntiBHadronFromTopB" );
    produces< std::vector<int> > ( "AntiBHadronVsJet" );


}

GenLevelBJetProducer::~GenLevelBJetProducer()
{
}


// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
/**
* @brief description of the run-time parameters
*
* <TABLE>
* <TR><TH> name                </TH><TH> description </TH> </TR>
* <TR><TD> ttGenEvent          </TD><TD> input collection of TtGenEvent, used to identify the b-quark from top </TD></TR>
* <TR><TD> genJets             </TD><TD> input GenJet collection </TD></TR>
* <TR><TD> deltaR              </TD><TD> maximum angle between hadron and GenJet </TD></TR>
* <TR><TD> noBBbarResonances   </TD><TD> exclude resonances to be identified as hadrons </TD></TR>
* <TR><TD> requireTopBquark    </TD><TD> only accept hadrons coming from the top-quark </TD></TR>
* <TR><TD> resolveParticleName </TD><TD> print particle name during warning and debug output instead of PDG ID </TD></TR>
* <TR><TD> flavour		</TD><TD> flavour of weakly decaying hadron that the jets should be matched to (5-b, 4-c) </TD></TR>
* </TABLE>
*
*/
void GenLevelBJetProducer::fillDescriptions ( edm::ConfigurationDescriptions& descriptions )
{

    edm::ParameterSetDescription desc;
    desc.add<edm::InputTag> ( "ttGenEvent",edm::InputTag ( "genEvt" ) )->setComment ( "Input collection of TtGenEvent, used to identify the quark from top" );
    desc.add<edm::InputTag> ( "genJets",edm::InputTag ( "ak5GenJets","","HLT" ) )->setComment ( "Input GenJet collection" );
    desc.add<double> ( "deltaR",.5 )->setComment ( "Maximum angle between hadron and GenJet" );
    desc.add<bool> ( "noBBbarResonances",true )->setComment ( "Exclude resonances to be identified as hadrons" );
    desc.add<bool> ( "requireTopBquark",false )->setComment ( "Only accept hadrons coming from the top-quark" );
    desc.add<bool> ( "resolveParticleName",false )->setComment ( "Print particle name during warning and debug output instead of PDG ID" );
    descriptions.add ( "produceGenLevelBJets",desc );
}



//
// member functions
//

// ------------ method called to produce the data  ------------
void GenLevelBJetProducer::produce ( edm::Event& evt, const edm::EventSetup& setup )
{

    setup.getData ( pdt_ );

    using namespace edm;

    std::auto_ptr<std::vector<int> > bIdx ( new std::vector<int> );
    std::auto_ptr<std::vector<int> > anti_bIdx ( new std::vector<int> );
    std::auto_ptr<std::vector<int> > bHadronVsJet ( new std::vector<int> );
    std::auto_ptr<std::vector<int> > anti_bHadronVsJet ( new std::vector<int> );
    std::auto_ptr<std::vector<reco::GenParticle> > bHadrons ( new std::vector<reco::GenParticle> );
    std::auto_ptr<std::vector<reco::GenParticle> > anti_bHadrons ( new std::vector<reco::GenParticle> );
    std::auto_ptr<std::vector<bool> > bHadronFromTopBqark ( new std::vector<bool> );
    std::auto_ptr<std::vector<bool> > anti_bHadronFromTopBqark ( new std::vector<bool> );

    edm::Handle<TtGenEvent> genEvt;
    evt.getByLabel ( ttGenEvent_, genEvt );

    edm::Handle<reco::GenJetCollection> genJets;
    evt.getByLabel ( genJets_, genJets );

    LogDebug ( "bJet" ) << "searching for b-jets in " << genJets_;
    *bIdx = getGenJetWith ( genEvt->b(), *genJets, *bHadrons, *bHadronFromTopBqark, *bHadronVsJet );
    LogDebug ( "bJet" ) << "searching for anti-b-jets in " << genJets_;
    *anti_bIdx = getGenJetWith ( genEvt->bBar(), *genJets, *anti_bHadrons, *anti_bHadronFromTopBqark, *anti_bHadronVsJet );

    evt.put ( bIdx,                "BHadJetIndex" );
    evt.put ( bHadrons,            "BHadrons" );
    evt.put ( bHadronFromTopBqark, "BHadronFromTopB" );
    evt.put ( bHadronVsJet,        "BHadronVsJet" );

    evt.put ( anti_bIdx,                "AntiBHadJetIndex" );
    evt.put ( anti_bHadrons,            "AntiBHadrons" );
    evt.put ( anti_bHadronFromTopBqark, "AntiBHadronFromTopB" );
    evt.put ( anti_bHadronVsJet,        "AntiBHadronVsJet" );

}

// ------------ method called once each job just before starting event loop  ------------
void GenLevelBJetProducer::beginJob()
{
}

// ------------ method called once each job just after ending the event loop  ------------
void GenLevelBJetProducer::endJob()
{
}

// ------------ method called when starting to processes a run  ------------
void GenLevelBJetProducer::beginRun ( edm::Run&, edm::EventSetup const& )
{
}

// ------------ method called when ending the processing of a run  ------------
void
GenLevelBJetProducer::endRun ( edm::Run&, edm::EventSetup const& )
{
}

// ------------ method called when starting to processes a luminosity block  ------------
void GenLevelBJetProducer::beginLuminosityBlock ( edm::LuminosityBlock&, edm::EventSetup const& )
{
}

// ------------ method called when ending the processing of a luminosity block  ------------
void GenLevelBJetProducer::endLuminosityBlock ( edm::LuminosityBlock&, edm::EventSetup const& )
{
}

// ------------ helper functions -------------

/**
* @brief identify the jets that contain b-hadrons
*
* All jets originating from a b-hadron with the right b content (b or anti-b) are identified in the GenJetCollection.
* This is done by searching through the generator particle decay tree starting from the constituents of the generator jets.
* The b-hadron which is lowest in the decay-chain (just before the weak decay of the b) is considered the b-hadron of this jet.
* Only jets within the given @f$\delta_{r}@f$ to the b-hadron are accepted.
* In case more than one jet originates from the same b-hadron, the jet which is nearer in @f$\delta_{r}@f$ is chosen.
*
* b-bbar resonances can either be considered b-hadrons or not depending on the configuration.
*
* The b-hadrons can be required to originate from the given b-quark depending on the configuration.
*
* To allow performance studies following informations are tracked and returned:
* \arg the GenParticles identified as b-hadrons
* \arg if the b-hadron originates from the top-b-quark
* \arg a matrix showing which jets contain particles from which b-hadron
*
* @param[in] bQuark used to set the charge of the b-Hadrons
* @param[in] genJets the GenJetCollection to be searched
* @param[out] bHadronObjects list of identified b-hadrons
* @param[out] isFromBquark tells which bHadrons originate from the given b-quark
* @param[out] bHadronsInJet relation between b-hadron and genJets. 0 => no daughters of bHadron in this jet, 1 => daughters of this bHadron in this jet. Access (iJet,iBhadron) -> [iJet * bHadronObject.size() + iBhadron]
* @returns a list with the indicies of the GenJets that fulfill the requirements
*/
std::vector<int> GenLevelBJetProducer::getGenJetWith ( const reco::Candidate* bQuark, const reco::GenJetCollection& genJets, std::vector<reco::GenParticle> &bHadronObjects, std::vector<bool> &isFromBquark, std::vector<int> &bHadronsInJet )
{

    std::vector<int> result;
    if ( ! bQuark ) {
        return result;    //no b-quark given, so so b-jets
    }

    std::vector<const reco::GenJet*> bQuarkCandidates;
    std::vector<const reco::GenJet*> bHadronCandidates;
    std::vector<size_t> bQuarkCandidateIndex;
    std::vector<size_t> bHadronCandidateIndex;
    std::vector<unsigned int> nBquarkParticles;
    std::vector<unsigned int> nBhadronParticles;
    std::vector<const reco::Candidate*> motherBhadron;

    typedef std::map<double, const reco::Candidate*> bHadronMap_t;
    bHadronMap_t bHadronList;
    typedef std::map<double, bool> bHadronFlagMap_t;
    bHadronFlagMap_t bHadronFlags;
    typedef std::map<double, std::vector<size_t> > jetCandidatesVsBhadron_t;
    jetCandidatesVsBhadron_t jetCandidatesVsBhadron;

    for ( size_t iJet = 0; iJet < genJets.size(); ++iJet ) {
        const reco::GenJet* thisJet = & ( genJets[iJet] );
        std::vector<const reco::GenParticle*> particles = thisJet->getGenConstituents();


        LogTrace ( "Jets" ) << printJetInfo ( iJet, thisJet );

        bool isBquarkCandidate = false;
        bool isBhadronCandidate = false;
        unsigned int nBquarkDaughters = 0;
        unsigned int nBhadronDaughters = 0;
        bHadronMap_t bHadrons;

        for ( unsigned int iParticle = 0; iParticle < particles.size(); ++iParticle ) {
            const reco::GenParticle* thisParticle = particles[iParticle];
            const reco::Candidate* bHadron = 0;
            std::vector<const reco::Candidate*> particleChain;
            checkForLoop ( particleChain,thisParticle );
            if ( searchInMothers ( bQuark, thisParticle, particleChain, &bHadron ) ) {
                isBquarkCandidate = true;
                ++nBquarkDaughters;
                if ( bHadron ) {
                    bHadronFlags[bHadron->p()] = true;
                }
            }
            if ( bHadron ) {
                isBhadronCandidate = true;
                ++nBhadronDaughters;
                bHadrons[bHadron->p()] = bHadron;
                bHadronList[bHadron->p()] = bHadron;
            }
        }
        if ( isBquarkCandidate ) {
            bQuarkCandidates.push_back ( thisJet );
            bQuarkCandidateIndex.push_back ( iJet );
            nBquarkParticles.push_back ( nBquarkDaughters );
        }
        if ( isBhadronCandidate && ( isBquarkCandidate || !requireTopBquark_ ) ) {
            bHadronCandidates.push_back ( thisJet );
            bHadronCandidateIndex.push_back ( iJet );
            nBhadronParticles.push_back ( nBhadronDaughters );
            motherBhadron.push_back ( bHadrons.begin()->second );
            for ( bHadronMap_t::iterator it = bHadrons.begin(); it != bHadrons.end(); ++it ) {
                if ( it->second->pt() > motherBhadron.back()->pt() ) {
                    motherBhadron.back() = it->second;    // this is only for debug output and not the real decision
                }
                jetCandidatesVsBhadron[it->first].push_back ( iJet );
            }
        }
    }

// debug output no functionality
#ifdef EDM_ML_DEBUG
    LogTrace ( "bQuark" )  << "found " << bQuarkCandidates.size() << " jets with b-quark particles" << std::endl;
    LogTrace ( "bHadron" ) << "found " << bHadronCandidates.size() << " jets with b-hadron particles" << std::endl
                           << "found " << bHadronList.size() << " different b-Hadrons" << std::endl;

    for ( unsigned int i = 0; i < bQuarkCandidates.size(); ++i ) {
        const reco::GenJet *jet = bQuarkCandidates.at ( i );
        size_t index = bQuarkCandidateIndex.at ( i );
        LogTrace ( "bQuark" ) << "GenJet " << index << " has " << nBquarkParticles.at ( i ) << "/" << jet->getGenConstituents().size() << " b-quark daughters" << std::endl
                              << "GenJet " << index << " " << jet->p4() << " p: " << jet->p() << " p_T: " << jet->pt() << std::endl
                              << "GenJet " << index << " eta: " << jet->eta() << " phi: " << jet->phi() << std::endl;
    }


    for ( unsigned int i = 0; i < bHadronCandidates.size(); ++i ) {
        const reco::GenJet *jet = bHadronCandidates.at ( i );
        size_t index = bHadronCandidateIndex.at ( i );
        const reco::Candidate *bMother = motherBhadron.at ( i );
        LogTrace ( "bHadron" ) << "GenJet " << index << " has " << nBhadronParticles.at ( i ) << "/" << jet->getGenConstituents().size() << " b-hadron daughters" << std::endl
                               << "GenJet " << index << " " << jet->p4() << " p: " << jet->p() << " p_T: " << jet->pt() << std::endl
                               << "GenJet " << index << " eta: " << jet->eta() << " phi: " << jet->phi() << std::endl
                               << "GenJet " << index << " mother b-hadron: " << getParticleName ( bMother->pdgId() ) <<  std::endl
                               << "GenJet " << index << " mother b-hadron: " << bMother->p4() << " p: " << bMother->p() << " p_T: " << bMother->pt() << std::endl
                               << "GenJet " << index << " mother b-hadron: eta: " << bMother->eta() << " phi: " << bMother->phi() << std::endl;
    }
#endif // EDM_ML_DEBUG -- debug output


    bHadronObjects.clear();
    isFromBquark.clear();
    bHadronsInJet.clear();

    unsigned int nJets = genJets.size();
    unsigned int nBhadrons = bHadronList.size();

    bHadronsInJet.resize ( nJets*nBhadrons,0 );

    for ( jetCandidatesVsBhadron_t::iterator it = jetCandidatesVsBhadron.begin(); it != jetCandidatesVsBhadron.end(); ++it ) {

        const reco::Candidate *bHadron = bHadronList[it->first];
        std::vector<size_t> candidateIdx = it->second;
        LogTrace ( "bHadron" ) << "analysing jets for " << getParticleName ( bHadron->pdgId() ) << std::endl;
        LogTrace ( "bHadron" ) << "   " << candidateIdx.size() <<  " candidate jets: ";

        unsigned int bHadronIndex = bHadronObjects.size();
        bHadronObjects.push_back ( * ( dynamic_cast<const reco::GenParticle*> ( bHadron ) ) );
        isFromBquark.push_back ( bHadronFlags[it->first] );

        std::vector<const reco::GenJet*> jetCandidates;
        for ( unsigned int idx = 0; idx < candidateIdx.size(); ++idx ) {
            LogTrace ( "bHadron" ) << "     " << candidateIdx[idx] << std::endl;
            jetCandidates.push_back ( & ( genJets[candidateIdx[idx]] ) );
            bHadronsInJet.at ( candidateIdx[idx]*nBhadrons + bHadronIndex ) = 1;
        }

        int bestJet = getGenJetNear ( bHadron, jetCandidates );
        if ( bestJet >= 0 ) {
            result.push_back ( candidateIdx.at ( bestJet ) );
            LogTrace ( "bHadron" ) << "    best matching jet: " << candidateIdx.at ( bestJet ) << std::endl;
        } else {
            LogTrace ( "bHadron" ) << "    no matching jet in cone of " << deltaR_ << std::endl;
        }
    }

    std::sort ( result.begin(),result.end() );

    return result;
}

/**
* @brief do a recursive search for the mother particles until the b-quark is found or the absolute mother is found
*
* the treatment of b-bar resonances depends on the global parameter noBBbarResonances_
*
* @param[in] bQuark ancestor b-quark for the current search
* @param[in] thisParticle current particle to be analysed
* @param[in] particleChain current version of the search path
* @param[out] bHadron the oldest b-hadron found in the search
*
* @returns if the b-quark was found or not
*/
bool GenLevelBJetProducer::searchInMothers ( const reco::Candidate* bQuark, const reco::Candidate* thisParticle, std::vector<const reco::Candidate*> particleChain, pCRC *bHadron )
{

    if ( *bHadron == 0 // find only the first b-hadron on the way (the one that decays weekly)
            && ( thisParticle->pdgId() / 1000  == bQuark->pdgId()  // b-baryions
                 || ( thisParticle->pdgId() / 100 % 10 == -bQuark->pdgId() // b-mesons
                      && ! ( noBBbarResonances_ && thisParticle->pdgId() / 10 % 100 == 55 ) // but not a b-bbar resonance
                    ) )
       ) {
        *bHadron = thisParticle;
    }

    for ( size_t iMother = 0; iMother < thisParticle->numberOfMothers(); ++iMother ) {
        const reco::Candidate* mother = thisParticle->mother ( iMother );
        if ( checkForLoop ( particleChain, mother ) ) {
            edm::LogWarning ( "decayChain" ) << "Identified a loop in the current decay chain."
                                             << " Paricle " << mother
                                             << " PDG: " << mother->pdgId()
//       << " " << mother->p4()
                                             << " pt: " << mother->pt() << ", eta: " << mother->eta()
                                             << " is already in the chain."
                                             << " Will stop this branch here. B-hadron identification might be incomplete."
                                             << " " << printParticleChain ( particleChain,*bHadron );
            return false;
        }
        if ( bQuark->p4() == mother->p4() && bQuark->pdgId() == mother->pdgId() && bQuark->status() == mother->status() ) {
            LogTrace ( "decayChain" ) << printParticleChain ( particleChain,*bHadron );
            return true;
        } else if ( searchInMothers ( bQuark, mother, particleChain, bHadron ) ) {
            return true;
        }
    }

    return false;
}


/**
* @brief helper function to keep track of the decay chain and identify loops in the decay tree
*
* @param[out] particleChain vector of particles building up the current chain
* @param[in] particle particle that should be added
*
* returns true if a particle is already in the chain
*/
bool GenLevelBJetProducer::checkForLoop ( std::vector<const reco::Candidate*> &particleChain, const reco::Candidate* particle )
{

    for ( unsigned int i = 0; i < particleChain.size(); ++i ) {
        if ( particleChain.at(i)->pdgId() == 91 || particleChain.at(i)->pdgId() == 92 ) {
            continue;    // Ignoring clusters and strings
        }
        if ( particleChain.at(i) ==  particle ) {
            return true;
        }
    }

    particleChain.push_back ( particle );
    return false;
}


/**
* @brief helper function to resolve realname of PDG-ID
*/
std::string GenLevelBJetProducer::getParticleName ( int id ) const
{

    const ParticleData * pd = 0;
    if ( resolveName_ ) {
        pdt_->particle ( id );
    }
    if ( !pd ) {
        std::ostringstream ss;
        ss << "P" << id;
        return ss.str();
    } else {
        return pd->name();
    }

}


/**
* @brief helper function to print jet properies
*
* this function is inlined to allow efficient optimisation when compiled without debug option
*
* @param[in] iJet the index of the jet
* @param[in] thisJet pointer to the jet
*
* @returns string to be printed
*/
inline std::string GenLevelBJetProducer::printJetInfo ( const size_t iJet, const reco::GenJet* thisJet ) const
{
    std::ostringstream out;
    out <<  "Jet: " << iJet
        << " particles: " << thisJet->getGenConstituents().size()
        << " p4: " << thisJet->p4()
        << " p_t: " << thisJet->pt()
        << std::endl;
    return out.str();
}

/**
* @brief helper function to generate a human readable representation of the decay chain
*
* this function is inlined to allow efficient optimisation when compiled without debug option
*
* @param[in] particleChain the decay chain
* @param[in] hadron the identified b-hadron
*
* @returns string to be printed
*/
inline std::string GenLevelBJetProducer::printParticleChain ( const std::vector<const reco::Candidate*> &particleChain, const reco::Candidate* hadron ) const
{
    std::ostringstream out;

    for ( int i = particleChain.size()-1; i >= 0; --i ) {
        if ( particleChain[i] == hadron ) {
            out << "*" << getParticleName ( particleChain[i]->pdgId() ) <<"*";
        } else {
            out << getParticleName ( particleChain[i]->pdgId() );
        }
        if ( i>0 ) {
            out  << "-->";
        }
    }
    return out.str();
}


/**
* @brief identify which of the jets is the nearest to the particle
*
* @param particle reference particle
* @param genJets candidate jets
* @returns index of the best jet in the vector or -1 if no jet within the maximum @f$\delta_{r}@f$
*/
int GenLevelBJetProducer::getGenJetNear ( const reco::Candidate* particle, std::vector<const reco::GenJet*> &genJets )
{
    int result = -1;
    double bestDr = deltaR_;
    for ( unsigned int i = 0; i < genJets.size(); ++i ) {
        double dr = deltaR ( genJets[i]->eta(), genJets[i]->phi(), particle->eta(), particle->phi() );
        if ( dr < bestDr ) {
            bestDr = dr;
            result = i;
        }
    }
    return result;
}



//define this as a plug-in
DEFINE_FWK_MODULE ( GenLevelBJetProducer );
